# Initial data preprocessing

## Project objectives

The AIM - AHEAD (Adherence Improvement Methods for Addressing Health
Equity and Disparities) project is a targeted initiative designed to
enhance our understanding and prediction of treatment adherence among
patients undergoing buprenorphine therapy for opioid use disorder (OUD).
Utilizing the extensive and detailed IQVIA medical claims longitudinal
data, this project aims to identify key factors influencing adherence
rates, develop predictive models to foresee adherence behaviors, and
ultimately devise strategies to improve treatment outcomes.

By leveraging advanced data analytics and machine learning techniques,
AIM - AHEAD seeks to provide actionable insights that can support
healthcare providers in optimizing buprenorphine treatment protocols,
reducing relapse rates, and promoting sustained recovery for individuals
struggling with OUD. Additionally, this project aims to address health
disparities and ensure equitable access to effective treatment options,
thereby contributing to the broader goal of improving public health
outcomes.

    knitr::opts_chunk$set(echo = TRUE, message = F, warning = F)
    setwd("A:/iqvia_bauer_extract_refresh/ANALYTICAL FILES")

    library(tidyverse)
    library(stringr)
    library(data.table)
    library(ggplot2) 
    library(plotly)
    library(usmap)
    library(gridExtra)

## Data sources

Data are obtained through Center of Health Care Data (CHCD) at UTHealth
Houston. Data are from 2006 to Apr 2023. The data include files with 1)
claims.csv; 2) enroll.csv (demographics); and 3) enroll2.csv
(enrollment) 4) rx\_lookup.csv 5) pos\_lookup.csv (places) 6)
pr\_lookup.csv (procedures) 7) dx\_lookup.csv (diagnosis).

### *claim.csv* file

*claims.csv* includes the following variables:

1.  **pat\_id**: Patient ID, a unique identifier for each patient.  

2.  **claimno**: Claim Number, a unique identifier for each insurance
    claim.  

3.  **rectype**: Record Type, indicates the type of record (e.g.,
    medical, pharmacy).  

4.  **proc\_cde**: Procedure Code, a code representing the medical
    procedure performed.  

5.  **ndc**: National Drug Code, a unique identifier for medications.  

6.  **dayssup**: Days Supply, the number of days the medication is
    intended to last.  

7.  **quan**: Quantity, the amount of medication or service provided.  

8.  **srv\_unit**: Service Unit, the unit of service provided (e.g.,
    number of visits).  

9.  **from\_dt**: From Date, the start date of the service or
    prescription.  

10. **to\_dt**: To Date, the end date of the service or prescription.  

11. **diagprc\_ind**: Diagnosis/Procedure Indicator, indicates if the
    code is a diagnosis or procedure. 1-ICD9, 2-ICD10, -1 - unknown  

12. **diag1**: Diagnosis Code 1, primary diagnosis code.  

13. **diag2**: Diagnosis Code 2, secondary diagnosis code.  

14. **diag3**: Diagnosis Code 3, tertiary diagnosis code.  

15. **diag4** to **diag12**: Diagnosis Code 4 - 12

16. **bill\_id**: Billing ID, a unique identifier for the billing
    record.  

17. **prscbr\_id**: Prescriber ID, a unique identifier for the
    healthcare provider who prescribed the medication.  

18. **month\_id**: Month ID, indicates the month the service or
    prescription occurred.  
    27: **year**: created variable - the year the service or
    prescription occurred. This comes from the from\_dt variable.

### *rx\_information.csv* file

    rx_info <- fread("../bauer_extract_rx_lookup.csv")
    head(rx_info)

*rx\_information.csv* includes the following variables:

1.  **ndc**: National Drug Code, a unique identifier for medications.  
2.  **product\_name**: Product Name, the brand name of the medication.  
3.  **generic\_name**: Generic Name, the generic name of the
    medication.  
4.  **gpi14**: GPI Code, a unique identifier for the therapeutic
    classification of the drug.  
5.  **thptc\_clas\_id**: Therapeutic Class ID, a unique identifier for
    the therapeutic class of the drug.  
6.  **thptc\_clas\_desc**: Therapeutic Class Description, a description
    of the therapeutic class of the drug.  
7.  **dosage\_form\_nm**: Dosage Form Name, the form in which the
    medication is administered (e.g., tablet, liquid).  
8.  **route**: Route, the route of administration of the medication
    (e.g., oral, intravenous).  
9.  **strength**: Strength, the concentration of the medication.  
10. **usc\_cd**: USC Code, a unique identifier for the uniform system of
    classification.  
11. **usc\_name**: USC Name, the name corresponding to the USC code.

### *Enroll.csv* file (demographics)

    ## Read in patient demographic data
    demo <- fread("../bauer_extract_enroll.csv")

    head(demo)

includes the following variables:

1.  **pat\_id**: Patient ID, a unique identifier for each patient.  
2.  **der\_sex**: Derived Sex, the gender of the patient.  
3.  **der\_yob**: Year of Birth, the year the patient was born.  
4.  **pat\_region**: Patient Region, the geographical region of the
    patient.  
5.  **pat\_state**: Patient State, the state where the patient
    resides.  
6.  **pat\_zip3**: Patient ZIP3, the first three digits of the patient’s
    ZIP code.

### *Enroll2.csv* file (enrollment)

Enroll2.csv includes the following variables:

1.  **pat\_id**: Patient ID, a unique identifier for each patient.  
2.  **pay\_type**: Payment Type, indicates the type of payment (e.g.,
    insurance, out-of-pocket).  
3.  **pcob\_type**: Pharmacy Coverage Type, indicates the type of
    pharmacy coverage.  
4.  **mcob\_type**: Medicare Coverage Type, indicates the type of
    Medicare coverage.  
5.  **month\_id**: Month ID, indicates the month of coverage. each
    patient may have multiple months of coverage. this is same as
    ‘from\_dt’ in claims, and used to filter patients enrolled &gt;
    12mos.

### *diagnosis.csv* file:

1.  **dx\_cd** A unique code assigned to a specific diagnosis. This code
    is typically used in medical records to identify and categorize
    diseases, conditions, and other health-related issues.  
2.  **dx\_cd** A unique code assigned to a specific diagnosis. This code
    is typically used in medical records to identify and categorize
    diseases, conditions, and other health-related issues. (with
    decimals)  
3.  **diagnosis\_desc** - A textual description of the diagnosis code.
    This provides more detailed information about the diagnosis, helping
    healthcare professionals understand the specifics of the condition
    or disease identified by the diagnosis code.  
4.  **diag\_vers\_typ\_id** An identifier that indicates the version and
    type of the diagnosis coding system used. 1-ICD9, 2-ICD10

### *pr\_lookup.csv* file:

1, **procedure\_cd** - procedure code  
2. **procedure** - procedure code c  
3. **procedure\_desc** - A textual description of the procedure code.  
4. **Procedure Type Code**  
C = CPT (Current Procedural Terminology)  
H = HCPCS (Healthcare Common Procedure Coding System)  
I = ICD (International Classification of Diseases)

1.  **Procedure Type Indicator** -1 = CPT or HCPCS  
    1 = ICD-9  
    2 = ICD-10

### *pos\_lookup.csv* file:

1.  place\_of\_svc\_cd - A unique code assigned to a specific place
    where medical services are provided.

2.  place\_of\_svc\_nm - The name of the place where medical services
    are provided.

3.  place\_of\_svc\_desc - A detailed description of the place of
    service. This description provides additional information about the
    nature of the service location, including its characteristics,
    functions, or specific types of services provided.

## Data filtering and linkage

Patient Enrollment Filtering: Claims data were filtered to include only
patients with enrollment periods exceeding 12 months. This criterion was
set to ensure that the data represented a sufficiently long period to
analyze treatment patterns and outcomes accurately.

Linking rx\_information: The rx\_information data was linked to the
claims data using National Drug Codes (NDCs). This linkage was essential
for integrating prescription information with the claims data.

Identifying Buprenorphine OUD Cohort: The buprenorphine opioid use
disorder (OUD) cohort was identified using the Universal Service Code
(usc\_cd) of 78430, which corresponds to ‘Drug Dependence’.

Chunk Processing Function: A custom function was written to process each
chunk of data separately. This approach ensured that the dataset was
handled efficiently and effectively, especially given the potentially
large size of the claims data. The processed chunks were then combined
into a single dataset.

Duplicate Removal: Duplicate entries were meticulously removed to
prevent redundancy and ensure the accuracy of the dataset.

Joining with Demographics: The resulting data frame was joined with
demographic information to create the final dataset, named
‘claims\_demo’. This final dataset integrated all necessary data
elements, including claims, prescriptions, and patient demographics,
providing a comprehensive foundation for subsequent analyses.

    ### Prescription dataset ###
    ## convert national drug code to character for formatting
    rx_info$ndc <- as.character(rx_info$ndc) 
    ## ncd should be 11-digit, for those less than 11 - pad by leading 0s
    rx_info$ndc <- stringi::stri_pad_left(rx_info$ndc, 11, "0")
    setkey(rx_info, ndc)

    ## Count total rows of claims data 
    ## claims_df <-  fread("../bauer_extract_claims.csv")
    n_total <- 90327620 #nrow(claims_df) # total n is 90327620
    ## rm(claims_df)

    ## read in full demographics dataset
    demo <- fread("../bauer_extract_enroll.csv")

    ## Define buprenorphine pattern (Dong et al. 2024)
    keywords <- c("BUNAVAIL", "BUPRENORPHINE/NALOX", "BUPRENORPHINE HCL", 
                  "BUPRENORPHINE HCL/NALOXON", "BUPRENORPHINE HYDROCHLORI", 
                  "PROBUPHINE IMPLANT KIT", "SUBLOCADE", "SUBOXONE", 
                  "SUBUTEX", "ZUBSOLV")
    pattern <- paste(keywords, collapse = "|")

**Due to memory limit, we need to filter and merge data by chunks**:

    ### Setup for chunking
    input_file <- "../bauer_extract_claims.csv"
    output_file <- "../Processed_data/claims_demo_filtered.csv" ## merged with demographics 
    log_file <- "../Processed_data/filter_log.csv" ## track the number by each step 
    chunk_size <- 5e6 # number of rows processed by each chunk
    i <- 0
    first_chunk <- TRUE
    filter_log <- list()
    filtered_all_chunks <- NULL

    ### start the data processing by chunk
    for (i in seq(0, n_total, by = chunk_size)) {
      
      nrows_to_read <- min(chunk_size, n_total - i)
      
      cat("Reading rows", i + 1, "to", i + nrows_to_read, "\n")
      
      ## read in claims data
      chunk <- fread(input_file, 
                     skip = i + (i > 0),
                     nrows = nrows_to_read, header = (i == 0))
      
      names(chunk) <- c("pat_id", "claimno", "rectype", "proc_cde", "ndc", "dayssup", "quan", "srv_unit", "from_dt", "to_dt", "diagprc_ind",
                        "diag1", "diag2", "diag3", "diag4", "diag5", "diag6", "diag7", "diag8", "diag9", "diag10", "diag11", "diag12", "bill_id",
                        "prscbr_id", "month_id")
      
      # count total number of diagnosis 
      n_diag <- sum(chunk[, paste0("diag", 1:12)] != "" & !is.na(chunk[, paste0("diag", 1:12)]))
      
      chunk$ndc <- as.character(chunk$ndc)
      
      ## for those with invalid NDC, set to missing 
      chunk <- chunk[!is.na(ndc) & ndc != "" & ndc != "0"]
      
      ndc_nonmissing_n <- nrow(chunk)
      ndc_nonmissing_p <- length(unique(chunk$pat_id))
      
      ## Merge with rx_info by 'ndc'
      chunk$ndc <- stringi::stri_pad_left(chunk$ndc, 11, "0")
      setkey(chunk, ndc)
      chunk <- rx_info[chunk, on = "ndc"]  # inner join keeps only matched ndc

      merged_n <- nrow(chunk[!is.na(chunk$usc_cd)])
      merged_p <- length(unique(chunk[!is.na(chunk$usc_cd)]$pat_id))
      
      ## Filter for usc_cd == "78340"
      chunk_final <- chunk[usc_cd == "78340"]
      usc_n <- nrow(chunk_final)
      usc_p <- length(unique(chunk_final$pat_id))

      ## Accumulate all filtered chunks for enrollment calc
      filtered_all_chunks <- rbindlist(list(filtered_all_chunks, chunk_final), use.names = TRUE, fill = TRUE)

      filter_log[[paste0("chunk_", i + 1)]] <- data.table(
        step = c("original", "n_diagnosis","no_missing_id", "non_missing_pat",
                 "rx_info_merged", "rx_info_merged_pat", 
                 "buprenorphine_filtered", "buprenorphine_filtered_pat"),
        n_rows = c(nrows_to_read, n_diag, ndc_nonmissing_n,ndc_nonmissing_p, merged_n, merged_p, usc_n, usc_p)
      )

      rm(chunk, chunk_final)
      gc()
    }


    ## Remove exact duplicates across chunks
    dedup_n <- nrow(unique(filtered_all_chunks))
    filtered_all_chunks1 <- distinct(filtered_all_chunks, .keep_all = T)
    dedup_pat <- length(unique(filtered_all_chunks1$pat_id))


    ## Calculate enrollment duration per patient
    filtered_all_chunks1[, from_dt := as.IDate(from_dt)]
    filtered_all_chunks1[, end_dt := as.IDate(to_dt)]
    #enrollment_days <- filtered_all_chunks[, .(enrollment_days = sum(as.integer(end_dt - from_dt), na.rm = TRUE)), by = pat_id]
    enrollment_days <- filtered_all_chunks1[
      , .(enrollment_days = as.integer(max(to_dt, na.rm = TRUE) - min(from_dt, na.rm = TRUE))), 
      by = pat_id
    ]

    # ## Filter patients with ≥ 365 days ??? Should we include this inclusion criteria? If so, is this the correct definition?
    # eligible_patients <- enrollment_days[enrollment_days >= 365, pat_id]
    # filtered_enroll <- filtered_all_chunks1[pat_id %in% eligible_patients]
    # enroll_n <- nrow(filtered_enroll)
    # enroll_pat <- length(unique(filtered_enroll$pat_id))

    ## we applied to 365 enrollment limit as the last step during the analytical cohort creation (defined below and skip for now)
    filtered_enroll <- filtered_all_chunks1

    ## Merge with demo by pat_id (left join)
    setkey(filtered_enroll, pat_id)
    setkey(demo, pat_id)
    filtered_final <- demo[filtered_enroll]  # retains all rows in filtered_enroll

    final_n <- nrow(filtered_final)
    final_pat <- length(unique(filtered_final$pat_id))

    demo_merge_n <- nrow(subset(filtered_final, ! filtered_final$der_sex %in% c("", " ") & !is.na(filtered_final$der_sex) & ! filtered_final$der_yob %in% c("", " ")  & !is.na(filtered_final$der_yob)))


    filtered_final1 <- filtered_final[grepl(pattern, product_name, ignore.case = TRUE) |
                         grepl(pattern, generic_name, ignore.case = TRUE)]
    final_n1 <- nrow(filtered_final1)
    final_pat1 <- length(unique(filtered_final1$pat_id))

    ## Save full filtered data
    fwrite(filtered_final1, output_file)

    ## Write log ##
    # Combine all per-chunk logs
    chunk_log <- rbindlist(filter_log, idcol = "chunk")

    ## Summarize across all chunks
    summary_by_step <- chunk_log[, .(n_rows = sum(n_rows)), by = step]
    summary_by_step[, chunk := "total_chunks"]

    ## Add final filtering steps
    final_steps <- data.table(
      chunk = "final",
      step = c("deduplicated records","deduplicated patients","demo_merged records", "final_filtered records", "final_filtered patients"),
      n_rows = c(dedup_n, dedup_pat,  demo_merge_n, final_n1, final_pat1)
    )

    ## Combine everything into final summary log
    filter_summary <- rbind(summary_by_step, final_steps)

    ## save it to csv
    fwrite(filter_summary, log_file)

    ## View log
    print(filter_summary)

The final cohort now has 4,487,148 claims total and 256,737 individual
patients.

## Additional Filtering

### 12 months continuous enrollment

To ensure complete treatment trajectories, we required a minimum of 12
months of continuous enrollment, as determined by IQVIA enrollment data.

    ## read in enrollment data (per record)
    enroll <- fread("../bauer_extract_enroll2.csv")

    ## merge with the final sample using pat_id and month_id
    claims_demo <- left_join(filtered_final1, enroll, by=c("pat_id", "month_id"))

    ## save data for further analysis 
    fwrite(claims_demo, "../Processed_data/claims_demo_enroll_filtered.csv")

    ##########################################
    # Two ways to calculate enrollment period
    ##########################################

    ### 1. Count the number of months enrolled regardless of gaps for each patient 
    enroll_month <- claims_demo %>%
      distinct(pat_id, month_id) %>%         # remove duplicate month entries per patient
      group_by(pat_id) %>%
      summarise(active_months = n()) %>%     # count unique months
      ungroup()

    ### how long pt enrolled ###### 
    CountOfMonths_enroll <- enroll_month %>% 
      mutate(months_group = case_when(
        active_months >= 1 & active_months < 12 ~ "< 1year",
        active_months >= 12 & active_months < 60 ~ "1-5 years", 
        active_months >= 60 & active_months < 120 ~ "5-10 years",
        active_months >= 120 & active_months < 180 ~ "10-15 years",
        active_months >= 180 & active_months < 240 ~ "15-20 years",
        active_months >= 240 ~ "> 20 years",
        TRUE ~ "NA" 
      ))

    CountOfMonths_enroll %>% 
      group_by(months_group) %>%
      summarise(Count = n(), .groups = 'drop') %>%
      mutate(Value = paste(Count, "(", round((Count/sum(Count))*100, 2), "%)")) %>% 
      select(-Count)

    enroll12mon <- CountOfMonths_enroll %>%
      filter(active_months >=12)

    enroll12mon_records <- claims_demo %>%
      filter(pat_id %in% enroll12mon$pat_id)

    ## save for future reference
    fwrite(enroll12mon_records, "../Processed_data/claims_demo_enroll_filtered_12mon_discrete.csv")

    ### this would exclude 2/3 of the patients

    ### 2. Calculate the time period as the difference between first treatment date (from_dt) and last treatment date (to_dt) for each patient 

    ### enrollment period calculated as number of days enrolled
    ### number of days with active treatment: each day counts once
    ### treatment duration: if two or more prescriptions overlap, then number of overlapped days are added to the end of final prescription for episode duration calculation only.

    claims_summary <- claims_demo %>%
      mutate(
        from_dt = as.Date(from_dt),
        to_dt = as.Date(to_dt),
        treatment_days = as.integer(to_dt - from_dt + 1)  # inclusive duration
      ) %>%
      group_by(pat_id) %>%
      summarise(
        enrollment_start = min(from_dt, na.rm = TRUE),
        enrollment_end   = max(to_dt, na.rm = TRUE),
        enrollment_days  = as.integer(enrollment_end - enrollment_start + 1),
        active_days      = sum(treatment_days, na.rm = TRUE),
        num_treatments   = n()
      ) %>%
      ungroup()

    ## filter patients with greater than 12 months of enrollment 
    cont_trt_12mon <- claims_summary[claims_summary$enrollment_days> 365,]

    claims_demo_12mon <- claims_demo %>%
      filter(pat_id %in% cont_trt_12mon$pat_id)

    ## this would exclude 3/5 patients 

    ## save this further filtered data
    fwrite(claims_demo_12mon, "../Processed_data/claims_demo_enroll_filtered_12mon.csv")

## Next Steps

Based on the initial data processing, it appears that we have sufficient
data to derive the analytical cohort. The upcoming steps include:

Missing Data Analysis: Conduct a thorough analysis of missing data to
understand the extent and impact of any gaps in the dataset. This
analysis will help in determining the best strategies for handling
missing values.

Exploratory Data Analysis (EDA): Perform comprehensive exploratory data
analysis to uncover initial insights, identify patterns. EDA will
involve generating summary statistics, visualizations, and initial
models to guide the development of more complex analyses.

Feature engineering and analytical cohort derivation: derive episode
duration, create the analytical cohort based on variaous inclusion and
exclusion criteria.
